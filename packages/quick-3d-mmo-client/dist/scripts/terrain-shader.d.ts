declare const VS1 = "\n\n// Triplanar Attributes\nin vec4 weights1;\nin vec4 weights2;\n\n// Outputs\nout vec3 vCoords;\nout vec4 vWeights1;\nout vec4 vWeights2;\n\n\n";
declare const VS2 = "\n\nvCoords = transformed.xyz;\nvWeights1 = weights1;\nvWeights2 = weights2;\n\n";
declare const VS = "\n\n// Attributes\nin vec3 coords;\nin vec3 color;\nin vec4 weights1;\nin vec4 weights2;\n\n// Outputs\nout vec2 vUV;\nout vec4 vColor;\nout vec3 vNormal;\nout vec3 vCoords;\nout vec4 vWeights1;\nout vec4 vWeights2;\n\nvoid main(){\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n  vUV = uv;\n  vNormal = normal;\n\n  vColor = vec4(color, 1);\n  vCoords = position.xyz;\n  vWeights1 = weights1;\n  vWeights2 = weights2;\n}\n  ";
declare const PS = "\n\nprecision highp float;\nprecision highp int;\nprecision highp sampler2DArray;\n\nuniform sampler2DArray TRIPLANAR_normalMap;\nuniform sampler2DArray TRIPLANAR_diffuseMap;\nuniform sampler2D TRIPLANAR_noiseMap;\n\nin vec3 vCoords;\nin vec4 vWeights1;\nin vec4 vWeights2;\n\n\nconst float _TRI_SCALE = 10.0;\n\nfloat sum( vec3 v ) { return v.x+v.y+v.z; }\n\nvec4 hash4( vec2 p ) {\n  return fract(\n    sin(vec4(1.0+dot(p,vec2(37.0,17.0)), \n              2.0+dot(p,vec2(11.0,47.0)),\n              3.0+dot(p,vec2(41.0,29.0)),\n              4.0+dot(p,vec2(23.0,31.0))))*103.0);\n}\n\nvec4 _TerrainBlend_4(vec4 samples[4]) {\n  float depth = 0.2;\n  float ma = max(\n      samples[0].w,\n      max(\n          samples[1].w,\n          max(samples[2].w, samples[3].w))) - depth;\n\n  float b1 = max(samples[0].w - ma, 0.0);\n  float b2 = max(samples[1].w - ma, 0.0);\n  float b3 = max(samples[2].w - ma, 0.0);\n  float b4 = max(samples[3].w - ma, 0.0);\n\n  vec4 numer = (\n      samples[0] * b1 + samples[1] * b2 +\n      samples[2] * b3 + samples[3] * b4);\n  float denom = (b1 + b2 + b3 + b4);\n  return numer / denom;\n}\n\nvec4 _TerrainBlend_4_lerp(vec4 samples[4]) {\n  return (\n      samples[0] * samples[0].w + samples[1] * samples[1].w +\n      samples[2] * samples[2].w + samples[3] * samples[3].w);\n}\n\n// Lifted from https://www.shadertoy.com/view/Xtl3zf\nvec4 texture_UV(in sampler2DArray srcTexture, in vec3 x) {\n  float k = texture(TRIPLANAR_noiseMap, 0.0025*x.xy).x; // cheap (cache friendly) lookup\n  float l = k*8.0;\n  float f = fract(l);\n  \n  float ia = floor(l+0.5); // suslik's method (see comments)\n  float ib = floor(l);\n  f = min(f, 1.0-f)*2.0;\n\n  vec2 offa = sin(vec2(3.0,7.0)*ia); // can replace with any other hash\n  vec2 offb = sin(vec2(3.0,7.0)*ib); // can replace with any other hash\n\n  vec4 cola = texture(srcTexture, vec3(x.xy + offa, x.z));\n  vec4 colb = texture(srcTexture, vec3(x.xy + offb, x.z));\n\n  return mix(cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola.xyz-colb.xyz)));\n}\n\nvec4 _Triplanar_UV(vec3 pos, vec3 normal, float texSlice, sampler2DArray tex) {\n  vec4 dx = texture_UV(tex, vec3(pos.zy / _TRI_SCALE, texSlice));\n  vec4 dy = texture_UV(tex, vec3(pos.xz / _TRI_SCALE, texSlice));\n  vec4 dz = texture_UV(tex, vec3(pos.xy / _TRI_SCALE, texSlice));\n\n  vec3 weights = abs(normal.xyz);\n  weights = weights / (weights.x + weights.y + weights.z);\n\n  return dx * weights.x + dy * weights.y + dz * weights.z;\n}\n\nvec4 _TriplanarN_UV(vec3 pos, vec3 normal, float texSlice, sampler2DArray tex) {\n  // Tangent Reconstruction\n  // Triplanar uvs\n  vec2 uvX = pos.zy; // x facing plane\n  vec2 uvY = pos.xz; // y facing plane\n  vec2 uvZ = pos.xy; // z facing plane\n  // Tangent space normal maps\n  vec3 tx = texture_UV(tex, vec3(uvX / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n  vec3 ty = texture_UV(tex, vec3(uvY / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n  vec3 tz = texture_UV(tex, vec3(uvZ / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n\n  vec3 weights = abs(normal.xyz);\n  weights = weights / (weights.x + weights.y + weights.z);\n\n  // Get the sign (-1 or 1) of the surface normal\n  vec3 axis = sign(normal);\n  // Construct tangent to world matrices for each axis\n  vec3 tangentX = normalize(cross(normal, vec3(0.0, axis.x, 0.0)));\n  vec3 bitangentX = normalize(cross(tangentX, normal)) * axis.x;\n  mat3 tbnX = mat3(tangentX, bitangentX, normal);\n\n  vec3 tangentY = normalize(cross(normal, vec3(0.0, 0.0, axis.y)));\n  vec3 bitangentY = normalize(cross(tangentY, normal)) * axis.y;\n  mat3 tbnY = mat3(tangentY, bitangentY, normal);\n\n  vec3 tangentZ = normalize(cross(normal, vec3(0.0, -axis.z, 0.0)));\n  vec3 bitangentZ = normalize(-cross(tangentZ, normal)) * axis.z;\n  mat3 tbnZ = mat3(tangentZ, bitangentZ, normal);\n\n  // Apply tangent to world matrix and triblend\n  // Using clamp() because the cross products may be NANs\n  vec3 worldNormal = normalize(\n      clamp(tbnX * tx, -1.0, 1.0) * weights.x +\n      clamp(tbnY * ty, -1.0, 1.0) * weights.y +\n      clamp(tbnZ * tz, -1.0, 1.0) * weights.z\n      );\n  return vec4(worldNormal, 0.0);\n}\n\nvec4 _Triplanar(vec3 pos, vec3 normal, float texSlice, sampler2DArray tex) {\n  vec4 dx = texture(tex, vec3(pos.zy / _TRI_SCALE, texSlice));\n  vec4 dy = texture(tex, vec3(pos.xz / _TRI_SCALE, texSlice));\n  vec4 dz = texture(tex, vec3(pos.xy / _TRI_SCALE, texSlice));\n\n  vec3 weights = abs(normal.xyz);\n  weights = weights / (weights.x + weights.y + weights.z);\n\n  return dx * weights.x + dy * weights.y + dz * weights.z;\n}\n\nvec4 _TriplanarN(vec3 pos, vec3 normal, float texSlice, sampler2DArray tex) {\n  vec2 uvx = pos.zy;\n  vec2 uvy = pos.xz;\n  vec2 uvz = pos.xy;\n  vec3 tx = texture(tex, vec3(uvx / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n  vec3 ty = texture(tex, vec3(uvy / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n  vec3 tz = texture(tex, vec3(uvz / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n\n  vec3 weights = abs(normal.xyz);\n  weights *= weights;\n  weights = weights / (weights.x + weights.y + weights.z);\n\n  vec3 axis = sign(normal);\n  vec3 tangentX = normalize(cross(normal, vec3(0.0, axis.x, 0.0)));\n  vec3 bitangentX = normalize(cross(tangentX, normal)) * axis.x;\n  mat3 tbnX = mat3(tangentX, bitangentX, normal);\n\n  vec3 tangentY = normalize(cross(normal, vec3(0.0, 0.0, axis.y)));\n  vec3 bitangentY = normalize(cross(tangentY, normal)) * axis.y;\n  mat3 tbnY = mat3(tangentY, bitangentY, normal);\n\n  vec3 tangentZ = normalize(cross(normal, vec3(0.0, -axis.z, 0.0)));\n  vec3 bitangentZ = normalize(-cross(tangentZ, normal)) * axis.z;\n  mat3 tbnZ = mat3(tangentZ, bitangentZ, normal);\n\n  vec3 worldNormal = normalize(\n      clamp(tbnX * tx, -1.0, 1.0) * weights.x +\n      clamp(tbnY * ty, -1.0, 1.0) * weights.y +\n      clamp(tbnZ * tz, -1.0, 1.0) * weights.z);\n  return vec4(worldNormal, 0.0);\n}\n\nvoid main() {\n  vec3 worldPosition = vCoords;\n\n  float weightIndices[4] = float[4](vWeights1.x, vWeights1.y, vWeights1.z, vWeights1.w);\n  float weightValues[4] = float[4](vWeights2.x, vWeights2.y, vWeights2.z, vWeights2.w);\n\n  // TRIPLANAR SPLATTING w/ NORMALS & UVS\n  vec3 worldSpaceNormal = normalize(vNormal);\n  vec4 diffuseSamples[4];\n  vec4 normalSamples[4];\n\n  for (int i = 0; i < 4; ++i) {\n    vec4 d = vec4(0.0);\n    vec4 n = vec4(0.0);\n    if (weightValues[i] > 0.0) {\n      d = _Triplanar_UV(\n        worldPosition, worldSpaceNormal, weightIndices[i], TRIPLANAR_diffuseMap);\n      n = _TriplanarN_UV(\n        worldPosition, worldSpaceNormal, weightIndices[i], TRIPLANAR_normalMap);\n\n      d.w *= weightValues[i];\n      n.w = d.w;\n    }\n\n    diffuseSamples[i] = d;\n    normalSamples[i] = n;\n  }\n\n  vec4 diffuseBlended = _TerrainBlend_4(diffuseSamples);\n  vec4 normalBlended = _TerrainBlend_4(normalSamples);\n  vec3 diffuse = diffuseBlended.xyz;\n\n  vec3 finalColour = diffuse;\n\n  // finalColour = vec3(sin(worldPosition.x), sin(worldPosition.y), sin(worldPosition.z));\n\n  gl_FragColor = vec4(finalColour, 1);\n}\n\n  ";
declare const PS1 = "\n\nprecision mediump sampler2DArray;\n\nuniform sampler2DArray TRIPLANAR_normalMap;\nuniform sampler2DArray TRIPLANAR_diffuseMap;\nuniform sampler2D TRIPLANAR_noiseMap;\n\nin vec3 vCoords;\nin vec4 vWeights1;\nin vec4 vWeights2;\n\n\nconst float _TRI_SCALE = 10.0;\n\nfloat sum( vec3 v ) { return v.x+v.y+v.z; }\n\nvec4 hash4( vec2 p ) {\n  return fract(\n    sin(vec4(1.0+dot(p,vec2(37.0,17.0)), \n              2.0+dot(p,vec2(11.0,47.0)),\n              3.0+dot(p,vec2(41.0,29.0)),\n              4.0+dot(p,vec2(23.0,31.0))))*103.0);\n}\n\nvec4 _TerrainBlend_4(vec4 samples[4]) {\n  float depth = 0.2;\n  float ma = max(\n      samples[0].w,\n      max(\n          samples[1].w,\n          max(samples[2].w, samples[3].w))) - depth;\n\n  float b1 = max(samples[0].w - ma, 0.0);\n  float b2 = max(samples[1].w - ma, 0.0);\n  float b3 = max(samples[2].w - ma, 0.0);\n  float b4 = max(samples[3].w - ma, 0.0);\n\n  vec4 numer = (\n      samples[0] * b1 + samples[1] * b2 +\n      samples[2] * b3 + samples[3] * b4);\n  float denom = (b1 + b2 + b3 + b4);\n  return numer / denom;\n}\n\nvec4 _TerrainBlend_4_lerp(vec4 samples[4]) {\n  return (\n      samples[0] * samples[0].w + samples[1] * samples[1].w +\n      samples[2] * samples[2].w + samples[3] * samples[3].w);\n}\n\n// Lifted from https://www.shadertoy.com/view/Xtl3zf\nvec4 texture_UV(in sampler2DArray srcTexture, in vec3 x) {\n  float k = texture(TRIPLANAR_noiseMap, 0.0025*x.xy).x; // cheap (cache friendly) lookup\n  float l = k*8.0;\n  float f = fract(l);\n  \n  float ia = floor(l+0.5); // suslik's method (see comments)\n  float ib = floor(l);\n  f = min(f, 1.0-f)*2.0;\n\n  vec2 offa = sin(vec2(3.0,7.0)*ia); // can replace with any other hash\n  vec2 offb = sin(vec2(3.0,7.0)*ib); // can replace with any other hash\n\n  vec4 cola = texture(srcTexture, vec3(x.xy + offa, x.z));\n  vec4 colb = texture(srcTexture, vec3(x.xy + offb, x.z));\n\n  return mix(cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola.xyz-colb.xyz)));\n}\n\nvec4 _Triplanar_UV(vec3 pos, vec3 normal, float texSlice, sampler2DArray tex) {\n  vec4 dx = texture_UV(tex, vec3(pos.zy / _TRI_SCALE, texSlice));\n  vec4 dy = texture_UV(tex, vec3(pos.xz / _TRI_SCALE, texSlice));\n  vec4 dz = texture_UV(tex, vec3(pos.xy / _TRI_SCALE, texSlice));\n\n  vec3 weights = abs(normal.xyz);\n  weights = weights / (weights.x + weights.y + weights.z);\n\n  return dx * weights.x + dy * weights.y + dz * weights.z;\n}\n\nvec4 _TriplanarN_UV(vec3 pos, vec3 normal, float texSlice, sampler2DArray tex) {\n  // Tangent Reconstruction\n  // Triplanar uvs\n  vec2 uvX = pos.zy; // x facing plane\n  vec2 uvY = pos.xz; // y facing plane\n  vec2 uvZ = pos.xy; // z facing plane\n  // Tangent space normal maps\n  vec3 tx = texture_UV(tex, vec3(uvX / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n  vec3 ty = texture_UV(tex, vec3(uvY / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n  vec3 tz = texture_UV(tex, vec3(uvZ / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n\n  vec3 weights = abs(normal.xyz);\n  weights = weights / (weights.x + weights.y + weights.z);\n\n  // Get the sign (-1 or 1) of the surface normal\n  vec3 axis = sign(normal);\n  // Construct tangent to world matrices for each axis\n  vec3 tangentX = normalize(cross(normal, vec3(0.0, axis.x, 0.0)));\n  vec3 bitangentX = normalize(cross(tangentX, normal)) * axis.x;\n  mat3 tbnX = mat3(tangentX, bitangentX, normal);\n\n  vec3 tangentY = normalize(cross(normal, vec3(0.0, 0.0, axis.y)));\n  vec3 bitangentY = normalize(cross(tangentY, normal)) * axis.y;\n  mat3 tbnY = mat3(tangentY, bitangentY, normal);\n\n  vec3 tangentZ = normalize(cross(normal, vec3(0.0, -axis.z, 0.0)));\n  vec3 bitangentZ = normalize(-cross(tangentZ, normal)) * axis.z;\n  mat3 tbnZ = mat3(tangentZ, bitangentZ, normal);\n\n  // Apply tangent to world matrix and triblend\n  // Using clamp() because the cross products may be NANs\n  vec3 worldNormal = normalize(\n      clamp(tbnX * tx, -1.0, 1.0) * weights.x +\n      clamp(tbnY * ty, -1.0, 1.0) * weights.y +\n      clamp(tbnZ * tz, -1.0, 1.0) * weights.z\n      );\n  return vec4(worldNormal, 0.0);\n}\n\nvec4 _Triplanar(vec3 pos, vec3 normal, float texSlice, sampler2DArray tex) {\n  vec4 dx = texture(tex, vec3(pos.zy / _TRI_SCALE, texSlice));\n  vec4 dy = texture(tex, vec3(pos.xz / _TRI_SCALE, texSlice));\n  vec4 dz = texture(tex, vec3(pos.xy / _TRI_SCALE, texSlice));\n\n  vec3 weights = abs(normal.xyz);\n  weights = weights / (weights.x + weights.y + weights.z);\n\n  return dx * weights.x + dy * weights.y + dz * weights.z;\n}\n\nvec4 _TriplanarN(vec3 pos, vec3 normal, float texSlice, sampler2DArray tex) {\n  vec2 uvx = pos.zy;\n  vec2 uvy = pos.xz;\n  vec2 uvz = pos.xy;\n  vec3 tx = texture(tex, vec3(uvx / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n  vec3 ty = texture(tex, vec3(uvy / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n  vec3 tz = texture(tex, vec3(uvz / _TRI_SCALE, texSlice)).xyz * vec3(2,2,2) - vec3(1,1,1);\n\n  vec3 weights = abs(normal.xyz);\n  weights *= weights;\n  weights = weights / (weights.x + weights.y + weights.z);\n\n  vec3 axis = sign(normal);\n  vec3 tangentX = normalize(cross(normal, vec3(0.0, axis.x, 0.0)));\n  vec3 bitangentX = normalize(cross(tangentX, normal)) * axis.x;\n  mat3 tbnX = mat3(tangentX, bitangentX, normal);\n\n  vec3 tangentY = normalize(cross(normal, vec3(0.0, 0.0, axis.y)));\n  vec3 bitangentY = normalize(cross(tangentY, normal)) * axis.y;\n  mat3 tbnY = mat3(tangentY, bitangentY, normal);\n\n  vec3 tangentZ = normalize(cross(normal, vec3(0.0, -axis.z, 0.0)));\n  vec3 bitangentZ = normalize(-cross(tangentZ, normal)) * axis.z;\n  mat3 tbnZ = mat3(tangentZ, bitangentZ, normal);\n\n  vec3 worldNormal = normalize(\n      clamp(tbnX * tx, -1.0, 1.0) * weights.x +\n      clamp(tbnY * ty, -1.0, 1.0) * weights.y +\n      clamp(tbnZ * tz, -1.0, 1.0) * weights.z);\n  return vec4(worldNormal, 0.0);\n}\n\n  ";
declare const PS2 = "\n\n{\n  vec3 worldPosition = vCoords;\n\n  float weightIndices[4] = float[4](vWeights1.x, vWeights1.y, vWeights1.z, vWeights1.w);\n  float weightValues[4] = float[4](vWeights2.x, vWeights2.y, vWeights2.z, vWeights2.w);\n  \n  // TRIPLANAR SPLATTING w/ NORMALS & UVS\n  vec3 worldSpaceNormal = normalize(vNormal);\n  vec4 diffuseSamples[4];\n  // vec4 normalSamples[4];\n  \n  for (int i = 0; i < 4; ++i) {\n    vec4 d = vec4(0.0);\n    // vec4 n = vec4(0.0);\n    if (weightValues[i] > 0.0) {\n      d = _Triplanar_UV(\n          worldPosition, worldSpaceNormal, weightIndices[i], TRIPLANAR_diffuseMap);\n      // n = _TriplanarN_UV(\n      //     worldPosition, worldSpaceNormal, weightIndices[i], TRIPLANAR_normalMap);\n  \n      d.w *= weightValues[i];\n      // n.w = d.w;\n    }\n  \n    diffuseSamples[i] = d;\n    // normalSamples[i] = n;\n  }\n  \n  vec4 diffuseBlended = _TerrainBlend_4(diffuseSamples);\n  // vec4 normalBlended = _TerrainBlend_4(normalSamples);\n  diffuseColor = sRGBToLinear(diffuseBlended);\n  // normal = normalBlended.xyz;\n}\n\n    ";
export { VS, PS, VS1, VS2, PS1, PS2, };
